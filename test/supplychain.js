// This script is designed to test the solidity smart contract - SuppyChain.sol -- and the various functions within
// Declare a variable and assign the compiled smart contract artifact
const SupplyChain = artifacts.require("SupplyChain");

const BN = web3.utils.BN;

contract("SupplyChain", async function (accounts) {
  // Declare few constants and assign a few sample accounts generated by ganache-cli
  const sku = 1;
  const upc = 1;
  const ownerID = accounts[0];
  const originFarmerID = accounts[1];
  const originFarmName = "John Doe";
  const originFarmInformation = "Yarray Valley";
  const originFarmLatitude = "-38.239770";
  const originFarmLongitude = "144.341490";
  const productID = sku + upc;
  const productNotes = "Best beans for Espresso";
  const productPrice = web3.utils.toWei(BN(1), "ether");
  const distributorID = accounts[2];
  const retailerID = accounts[3];
  const consumerID = accounts[4];
  const guestAddress = accounts[5];
  const FARMER_ROLE = web3.utils.keccak256("FARMER_ROLE");
  const DISTRIBUTOR_ROLE = web3.utils.keccak256("DISTRIBUTOR_ROLE");
  const RETAILER_ROLE = web3.utils.keccak256("RETAILER_ROLE");
  const CONSUMER_ROLE = web3.utils.keccak256("CONSUMER_ROLE");

  const STATUS = {
    Harvested: 0,
    Processed: 1,
    Packed: 2,
    ForSale: 3,
    Sold: 4,
    Shipped: 5,
    Received: 6,
    Purchased: 7,
  };

  // Available Accounts
  // (0) 0x22a1ed02e96d0da1530da0f593510484228d5ec7
  // (1) 0xdece2fc0f8a19dd95ebf545499d7f31bdd93cf8b
  // (2) 0xbf2b3545794a74af1998dd6b10a9e143baad25f0
  // (3) 0x40c8a74a253bfc08b2ee96f70a8fa4585eaf2bd6
  // (4) 0x48de6f1ad236ed9dd6ef6b1a6dce162f7f2da3db
  // (5) 0x450e60667592b2cfd847724f635ae3149db35add
  // (6) 0xd01dc2cb3ce421783919a02c9ae4ae99501a5499
  // (7) 0x138c49069cc320d461100c17951720744ac35127
  // (8) 0x5a9e7d66e335e8f7e5e77382f7701f5d9300540f
  // (9) 0xedf03ab8f41faeb07c0f806d3ae8aa24cad44225

  console.log("ganache-cli accounts used here...");
  console.log("Contract Owner: accounts[0] ", accounts[0]);
  console.log("Farmer: accounts[1] ", accounts[1]);
  console.log("Distributor: accounts[2] ", accounts[2]);
  console.log("Retailer: accounts[3] ", accounts[3]);
  console.log("Consumer: accounts[4] ", accounts[4]);

  let instance;

  const runItemTests = async (instance, context) => {
    // Retrieve the just now saved item from blockchain by calling function fetchItem()
    const resultBufferOne = await instance.fetchItemBufferOne.call(upc);
    const resultBufferTwo = await instance.fetchItemBufferTwo.call(upc);

    // Verify the result set
    assert.equal(resultBufferOne[0], sku, "Error: Invalid item SKU");

    assert.equal(resultBufferOne[1], upc, "Error: Invalid item UPC");

    assert.equal(
      resultBufferOne[2],
      context.ownerID,
      "Error: Missing or Invalid ownerID"
    );

    assert.equal(
      resultBufferOne[3],
      originFarmerID,
      "Error: Missing or Invalid originFarmerID"
    );

    assert.equal(
      resultBufferOne[4],
      originFarmName,
      "Error: Missing or Invalid originFarmName"
    );

    assert.equal(
      resultBufferOne[5],
      originFarmInformation,
      "Error: Missing or Invalid originFarmInformation"
    );

    assert.equal(
      resultBufferOne[6],
      originFarmLatitude,
      "Error: Missing or Invalid originFarmLatitude"
    );

    assert.equal(
      resultBufferOne[7],
      originFarmLongitude,
      "Error: Missing or Invalid originFarmLongitude"
    );

    assert.equal(resultBufferTwo[2], productID, "Error: Invalid productID");

    if (context.distributorID) {
      assert.equal(
        resultBufferTwo[6],
        context.distributorID,
        "Error: Missing or Invalid distributorID"
      );
    }

    if (context.retailerID) {
      assert.equal(
        resultBufferTwo[7],
        context.retailerID,
        "Error: Missing or Invalid retailerID"
      );
    }

    if (context.consumerID) {
      assert.equal(
        resultBufferTwo[8],
        context.consumerID,
        "Error: Missing or Invalid consumerID"
      );
    }

    assert.equal(
      resultBufferTwo[5],
      context.status,
      "Error: Invalid item Status"
    );

    assert.equal(
      context.actionResult.logs[0].event === context.eventName,
      true,
      "Invalid event emitted"
    );

    // Verify the result set
  };

  before(async () => {
    instance = await SupplyChain.deployed();

    await instance.grantRole(FARMER_ROLE, originFarmerID, { from: ownerID });
    await instance.grantRole(DISTRIBUTOR_ROLE, distributorID, {
      from: ownerID,
    });
    await instance.grantRole(RETAILER_ROLE, retailerID, { from: ownerID });
    await instance.grantRole(CONSUMER_ROLE, consumerID, { from: ownerID });
  });

  // 1st Test
  it("Testing smart contract function harvestItem() that allows a farmer to harvest coffee", async () => {
    // Mark an item as Harvested by calling function harvestItem()
    const result = await instance.harvestItem(
      upc,
      originFarmerID,
      originFarmName,
      originFarmInformation,
      originFarmLatitude,
      originFarmLongitude,
      productNotes,
      {
        from: originFarmerID,
      }
    );

    await runItemTests(instance, {
      actionResult: result,
      ownerID: originFarmerID,
      status: STATUS.Harvested,
      eventName: "Harvested",
    });
  });

  // 2nd Test
  it("Testing smart contract function processItem() that allows a farmer to process coffee", async () => {
    // Mark an item as Processed by calling function processItem()
    const result = await instance.processItem(upc, {
      from: originFarmerID,
    });

    await runItemTests(instance, {
      actionResult: result,
      ownerID: originFarmerID,
      status: STATUS.Processed,
      eventName: "Processed",
    });
  });

  // 3rd Test
  it("Testing smart contract function packItem() that allows a farmer to pack coffee", async () => {
    const instance = await SupplyChain.deployed();

    const result = await instance.packItem(upc, {
      from: originFarmerID,
    });

    await runItemTests(instance, {
      actionResult: result,
      ownerID: originFarmerID,
      status: STATUS.Packed,
      eventName: "Packed",
    });
  });

  // 4th Test
  it("Testing smart contract function sellItem() that allows a farmer to sell coffee", async () => {
    const result = await instance.sellItem(upc, productPrice, {
      from: originFarmerID,
    });

    await runItemTests(instance, {
      actionResult: result,
      ownerID: originFarmerID,
      status: STATUS.ForSale,
      eventName: "ForSale",
    });
  });

  // 5th Test
  it("Testing smart contract function buyItem() that allows a distributor to buy coffee", async () => {
    const result = await instance.buyItem(upc, {
      from: distributorID,
      value: productPrice,
    });

    await runItemTests(instance, {
      distributorID,
      actionResult: result,
      ownerID: distributorID,
      status: STATUS.Sold,
      eventName: "Sold",
    });
  });

  // 6th Test
  it("Testing smart contract function shipItem() that allows a distributor to ship coffee", async () => {
    const result = await instance.shipItem(upc, {
      from: distributorID,
    });

    await runItemTests(instance, {
      distributorID,
      actionResult: result,
      ownerID: distributorID,
      status: STATUS.Shipped,
      eventName: "Shipped",
    });
  });

  // 7th Test
  it("Testing smart contract function receiveItem() that allows a retailer to mark coffee received", async () => {
    const result = await instance.receiveItem(upc, {
      from: retailerID,
    });

    await runItemTests(instance, {
      retailerID,
      ownerID: retailerID,
      actionResult: result,
      status: STATUS.Received,
      eventName: "Received",
    });
  });

  // 8th Test
  it("Testing smart contract function purchaseItem() that allows a consumer to purchase coffee", async () => {
    const result = await instance.purchaseItem(upc, {
      from: consumerID,
      value: productPrice,
    });

    await runItemTests(instance, {
      consumerID,
      actionResult: result,
      ownerID: consumerID,
      status: STATUS.Purchased,
      eventName: "Purchased",
    });
  });

  // 9th Test
  it("Testing smart contract function fetchItemBufferOne() that allows anyone to fetch item details from blockchain", async () => {
    // Retrieve the just now saved item from blockchain by calling function fetchItem()
    const resultBufferOne = await instance.fetchItemBufferOne.call(upc, {
      from: guestAddress,
    });

    assert.equal(resultBufferOne[0], sku, "Error: Invalid item SKU");

    assert.equal(resultBufferOne[1], upc, "Error: Invalid item UPC");

    assert.equal(
      resultBufferOne[2],
      consumerID,
      "Error: Missing or Invalid ownerID"
    );

    assert.equal(
      resultBufferOne[3],
      originFarmerID,
      "Error: Missing or Invalid originFarmerID"
    );

    assert.equal(
      resultBufferOne[4],
      originFarmName,
      "Error: Missing or Invalid originFarmName"
    );

    assert.equal(
      resultBufferOne[5],
      originFarmInformation,
      "Error: Missing or Invalid originFarmInformation"
    );

    assert.equal(
      resultBufferOne[6],
      originFarmLatitude,
      "Error: Missing or Invalid originFarmLatitude"
    );

    assert.equal(
      resultBufferOne[7],
      originFarmLongitude,
      "Error: Missing or Invalid originFarmLongitude"
    );
  });

  // 10th Test
  it("Testing smart contract function fetchItemBufferTwo() that allows anyone to fetch item details from blockchain", async () => {
    // Retrieve the just now saved item from blockchain by calling function fetchItem()
    const resultBufferTwo = await instance.fetchItemBufferTwo.call(upc, {
      from: guestAddress,
    });

    assert.equal(resultBufferTwo[2], productID, "Error: Invalid productID");

    assert.equal(
      resultBufferTwo[6],
      distributorID,
      "Error: Missing or Invalid distributorID"
    );

    assert.equal(
      resultBufferTwo[7],
      retailerID,
      "Error: Missing or Invalid retailerID"
    );

    assert.equal(
      resultBufferTwo[8],
      consumerID,
      "Error: Missing or Invalid consumerID"
    );

    assert.equal(
      resultBufferTwo[5],
      STATUS.Purchased,
      "Error: Invalid item Status"
    );
  });
});
